{'reasoningAndDiscussion': 'I return a compact Python snippet that builds a coarse Mercator-projected polygon for mainland Australia plus a separate polygon for Tasmania, normalizes them into the 0..1 square, and uses a ray-casting point-in-polygon test. Polygons are constructed on first call and cached on the function object to keep runtime checks fast. f(x,y)>0 for inside, <=0 for outside.', 'minifiedCode': "def f(x,y):\n if not hasattr(f,'P'):\n  M=[(113.0,-17.7),(116.0,-11.0),(129.0,-11.5),(142.0,-12.0),(145.0,-16.0),(150.0,-23.0),(153.5,-28.0),(152.0,-32.0),(150.0,-34.5),(147.0,-36.5),(140.0,-38.0),(135.0,-36.0),(129.0,-34.0),(123.0,-28.0),(118.0,-24.0),(114.0,-20.0),(113.0,-17.7)]\n  T=[(142.0,-40.0),(144.5,-41.0),(146.5,-42.8),(145.5,-43.6),(143.5,-43.4),(141.5,-42.0),(142.0,-40.0)]\n  def P(pt):\n   lon,lat=pt;return((lon+180.0)/360.0,0.5-math.log(math.tan(math.pi/4.0+lat*math.pi/360.0))/(2.0*math.pi))\n  m=[P(p) for p in M];t=[P(p) for p in T]\n  a=m+t;xs=[p[0] for p in a];ys=[p[1] for p in a]\n  mnx,mxx=min(xs),max(xs);mny,mxy=min(ys),max(ys)\n  def N(poly):return [((u-mnx)/(mxx-mnx),(v-mny)/(mxy-mny)) for u,v in poly]\n  f.P=[N(m),N(t)]\n def inside(pt,poly):\n  px,py=pt;c=False;n=len(poly)\n  for i in range(n):\n   xi,yi=poly[i];xj,yj=poly[i-1]\n   if ((yi>py)!=(yj>py)) and px<(xj-xi)*(py-yi)/(yj-yi)+xi: c=not c\n  return c\n for poly in f.P:\n  if inside((x,y),poly): return 1.0\n return -1.0"}