{'reasoningAndDiscussion': 'I provide a compact Python snippet that defines f(x,y) (normalized 0..1 coordinates). It contains a coarse multipolygon for mainland Australia and Tasmania in lon/lat, projects them with a Mercator projection to 2D, normalizes to 0..1, and then offers f(x,y)>0 when the point is inside any polygon, <=0 otherwise. For outside points the function returns a negative distance to the nearest polygon edge (so values are continuous and informative). No extra imports are used beyond those you stated would be prepended.', 'minifiedCode': 'polys_ll=[[(113,-22),(113,-13),(130,-10),(142,-11),(153,-12),(154,-24),(153,-35),(149,-38),(147,-38),(141,-39),(132,-35),(124,-33),(116,-28),(115,-20),(113,-22)],[(144.5,-43.6),(146.5,-43.4),(148.3,-42.2),(148.0,-41.0),(146.2,-40.5),(144.0,-41.2),(144.0,-42.5),(144.5,-43.6)]]\ndef _merc(lon,lat):\n    r=math.pi/180\n    x=(lon+180.0)/360.0\n    y=0.5-math.log(math.tan(math.pi/4+lat*r/2))/(2*math.pi)\n    return x,y\n_pts=[]\nfor poly in polys_ll:\n    a=[]\n    for lon,lat in poly:\n        a.append(_merc(lon,lat))\n    _pts.append(a)\nxs=[p[0] for poly in _pts for p in poly]\nys=[p[1] for poly in _pts for p in poly]\n_minx,miny,maxx,maxy=min(xs),min(ys),max(xs),max(ys)\n_wx=maxx-minx or 1e-9\n_wy=maxy-miny or 1e-9\npolys=[ [((p[0]-_minx)/_wx,(p[1]-_miny)/_wy) for p in poly] for poly in _pts]\ndef _pip(x,y,poly):\n    inside=False\n    n=len(poly)\n    j=n-1\n    for i in range(n):\n        xi,yi=poly[i]\n        xj,yj=poly[j]\n        if ((yi>y)!=(yj>y)) and (x < (xj-xi)*(y-yi)/(yj-yi+1e-20)+xi):\n            inside=not inside\n        j=i\n    return inside\n\ndef _mindist(x,y,poly):\n    md=1e9\n    for i in range(len(poly)):\n        ax,ay=poly[i]\n        bx,by=poly[(i+1)%len(poly)]\n        vx=bx-ax; vy=by-ay\n        wx=x-ax; wy=y-ay\n        d=vx*vx+vy*vy\n        t=0.0 if d==0 else max(0.0,min(1.0,(wx*vx+wy*vy)/d))\n        px=ax+vx*t; py=ay+vy*t\n        dx=x-px; dy=y-py\n        dist=math.hypot(dx,dy)\n        if dist<md: md=dist\n    return md\n\ndef f(x,y):\n    try:\n        xf=float(x); yf=float(y)\n    except:\n        return -1.0\n    for poly in polys:\n        if _pip(xf,yf,poly):\n            return 1.0\n    md=min(_mindist(xf,yf,poly) for poly in polys)\n    return -md'}